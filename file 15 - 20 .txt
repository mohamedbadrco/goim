package main

import (
    "fmt"
    //  "image/png"
     "image/draw"
	"image/color"
     "image/color/palette"
    // "log"
	"bufio"
    "os"
    "github.com/nfnt/resize"
    "github.com/fogleman/gg"  
    "math/rand"
     "image/gif"
     // "encoding/binary"
    "image"
   // "image/jpeg"
    
    // "io"
   // "github.com/andybons/gogif"
   "time"
   "io/ioutil"

    "github.com/golang/freetype"
    "github.com/golang/freetype/truetype"
)

// func init() {
//     // damn important or else At(), Bounds() functions will
//     // caused memory pointer error!!
//     image.RegisterFormat("jpeg", "jpeg", jpeg.Decode, jpeg.DecodeConfig)
// }

func g103d02g(path string)  {
    // size := 60

	rand.Seed(time.Now().UnixNano())


    fontFile := "/home/mohmedbadrco/goimage/font/Audiowide-Regular.ttf"
    fontBytes, err := ioutil.ReadFile(fontFile)
    fontb, err := freetype.ParseFont(fontBytes)
    // font

    face := truetype.NewFace(fontb, &truetype.Options{Size: 14 ,DPI: 90})

    
	inputFile , err := os.Open(path)
	defer inputFile.Close()
	if err != nil {
		panic(err)
	}

	r := bufio.NewReader(inputFile)
   GIF,err := gif.DecodeAll(r)
//    fmt.Println(g.Image[0].Bounds().Max.X ,err)
 
    // imData, err := png.Decode(catFile)
    // if err != nil {
	// 	// Handle error
	// }
	if err != nil {
		// Handle error
	}
	
   // fmt.Println(imData)

//    _ = imageType
    framesc := len(GIF.Image)
	var frames [8] image.Image
    
    for i := 0;i<framesc;i++{
    imDatan := resize.Resize(0,80, GIF.Image[i], resize.Lanczos3)
	frames[i] = imDatan
 }

    
      
    // const int  ax = imDatan.Bounds().Max.X

    var am [][][2] int


    

   // gscale := "$@B%8&WẄMÄÚŬÛŮÜŨ#*oöøäahkbdpqÞwmZŽO0QLCJUYŸXzcvunxrjft/|()1{}[]?-_+~<>i!lI½¼;:,\"^`'. "
   gscale := "$@B%8&WẄMÄŨ#*oöøäahkbdpqÞwmZŽŒO0QLCJUYŸXzcvüűضصثقفغعهخحيبلاتنمكطئءؤرلاىةوزظunxrjft?-_+~<>i!lI½¼;:,\"^`'. "

    glen := len(gscale)

     rn := rand.Intn(len(gscale) - 10)

      gscale = gscale[rn:rn+1+rand.Intn(glen - rn )]
      gscale += "  "
	// gscale = gscale[rn:]


      glen = len(gscale)
    
    g := rand.Intn(20) + 10
    vis := true
   
	imDatan := frames[0]

   
        for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ {
                    var subam  [][2] int
            for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
            c := color.GrayModel.Convert(imDatan.At(x, y)).(color.Gray)
           
            if (g > 0){
                g--
            }

            if(g <= 0){
                vis = !(vis)
              //  fmt.Println(vis)
                g = rand.Intn(20) + 10
               // fmt.Println(g)
            }
           // fmt.Println(int(c.Y))
            avg := int(((int(c.Y) * glen) / 255))
            if (avg > (glen - 1)){
                avg = glen - 1
            }
            // fmt.Println(avg)
         // k := gscale[avg];
         if(vis){
            if (g == 1){
                var gh = [2] int {avg,1}
                subam = append(subam,gh)

            }else{

                var gh = [2] int {avg,0}
                subam = append(subam,gh)
            }
            
         }else{
            var gh = [2] int {avg,2}
                subam = append(subam,gh)
         }
        
          
            
            // pimage(dc, imDatan.At(x, y), x * 14 ,14 + y *14,string(k))
        }
        am = append(am,subam)
    }
    
    var rcolors [][3] int

	for i := 0;i<10;i++{
		var gh = [3] int {rand.Intn(255),rand.Intn(255),rand.Intn(255)}
    rcolors = append(rcolors,gh)
	}  
	ho := 0

    var images []*image.Paletted

    var delays []  int 

    for i := 0; i < 80; i++{
		imDatan = frames[i%8]
        dc := gg.NewContext(imDatan.Bounds().Max.X * 14, imDatan.Bounds().Max.Y * 14)

        dc.SetFontFace(face)

        dc.SetRGB(0, 0, 0)
        dc.Fill()
         

        for j := 0; j < len(am) - 1; j++{
        tem := am[j][0][1]
        am[j][0][1] = am[j][len(am[0])-1][1]
        
        
            for k := len(am[0]) - 1; k > 1; k--{
                // fmt.Println(am[j][k][1],am[j][k-1][1])
               am[j][k][1] = am[j][k-1][1]
              // fmt.Println(am[j][k])
                
            }
            am[j][1][1] = tem
        }
		for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ {
			for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
			c := color.GrayModel.Convert(imDatan.At(x, y)).(color.Gray)
		   // fmt.Println(int(c.Y))
			avg := int(((int(c.Y) * glen) / 255))
			if (avg > (glen - 1)){
				avg = glen - 1
			}
			// fmt.Println(avg)
		 // k := gscale[avg]; 
		// fmt.Println(am[x][y][0])
		 am[x][y][0] = avg
	   //   fmt.Println(am[x][y][0])
	   }}

        offrand1 := 0
        offrand2 := 0


		
		v := [2]int{-1,1}
		offrand1 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*1.2 ))*v[rand.Intn(2)] )
		offrand2 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*1.2 ))*v[rand.Intn(2)] )
		ho = rand.Intn(2*20)
        if!(ho > 3){

            // gscale := "$@B%8&WẄMÄÚŬÛŮÜŨ#*oöøäahkbdpqÞwmZŽO0QLCJUYŸXzcvunxrjft/|()1{}[]?-_+~<>i!lI½¼;:,\"^`'. "
            gscale = "$@B%8&WẄMÄŨ#*oöøäahkbdpqÞwmZŽŒO0QLCJUYŸXzcvüűضصثقفغعهخحيبلاتنمكطئءؤرلاىةوزظunxrjft?-_+~<>i!lI½¼;:,\"^`'. "
         
             glen = len(gscale)
         
              rn = rand.Intn(len(gscale) - 10)
         
                gscale = gscale[rn:rn+1+rand.Intn(glen - rn )]
                gscale += "  "
             // gscale = gscale[rn:]
         
         
               glen = len(gscale)
        
            
                 for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ {
                     for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
                     c := color.GrayModel.Convert(imDatan.At(x, y)).(color.Gray)
                    // fmt.Println(int(c.Y))
                     avg := int(((int(c.Y) * glen) / 255))
                     if (avg > (glen - 1)){
                         avg = glen - 1
                     }
                     // fmt.Println(avg)
                  // k := gscale[avg]; 
                 // fmt.Println(am[x][y][0])
                  am[x][y][0] = avg
                //   fmt.Println(am[x][y][0])
                }}
                  

		}

            for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ { 
				if(rand.Intn(20) > 15){
					v := [2]int{-1,1}
					offrand1 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*1.2 ))*v[rand.Intn(2)] )
					offrand2 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*1.2 ))*v[rand.Intn(2)] )
				}
				
                for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {


					if(rand.Intn(20) > 15){
						v := [2]int{-1,1}
						offrand1 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*1.2 ))*v[rand.Intn(2)])
						offrand2 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*1.2 ))*v[rand.Intn(2)] )
					}
				
					
                    aR, aG, aB, aA := imDatan.At(x, y).RGBA() // no more error
                _ ,_,_= aR, aG, aB
                glen = len(gscale)
                index := int((float64(am[x][y][0])/float64(glen))*float64(len(rcolors)))
				rc  := rcolors[index]
                // fmt.Println(index)
				if(ho > 3 && i != 0){
               if(am[x][y][1] == 0){
                
                pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 ,14 + y *14,string(gscale[am[x][y][0]]))
              pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 ,21 + y *14,string(gscale[am[x][y][0]]))
				


               }
               if(am[x][y][1] == 1){
                
                pimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 ,14 + y *14,string(gscale[am[x][y][0]]))
                pimage(dc, color.RGBA{255, 255, 255, uint8(((aA/8)) >>  8) }, x * 14 + 7 ,21 + y *14,string(gscale[am[x][y][0]]))

               } } else{
                 
				if(am[x][y][1] == 0){
                
					pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 + offrand1 ,14 + y *14 + offrand2,string(gscale[am[x][y][0]]))
				  pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 +offrand1,21 + y *14 + offrand2,string(gscale[am[x][y][0]]))
					
	
	
				   }
				   if(am[x][y][1] == 1){
					
					pimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 + offrand1 ,14 + y *14 + offrand2,string(gscale[am[x][y][0]]))
					pimage(dc, color.RGBA{255, 255, 255, uint8(((aA/8)) >>  8) }, x * 14 + 7 +offrand1,21 + y *14 + offrand2,string(gscale[am[x][y][0]]))
	
				   }

               }

            } 
       
    }

  _ , _ = offrand1,offrand2
    delays = append(delays,7)

    dc.Clip()
    
    bbb := dc.Image()

    palettedImage := image.NewPaletted(image.Rect(0, 0, bbb.Bounds().Max.X, bbb.Bounds().Max.Y), palette.Plan9)
    draw.Draw(palettedImage, palettedImage.Rect, bbb,bbb.Bounds().Min, draw.Over)
     images = append(images,palettedIma
     ge)
	  //  dc.SavePNG(fmt.Sprintf("f/a%d.png", i))

}
  now := time.Now()
    name := fmt.Sprintf("out/%srbg.gif",now)
f, err := os.OpenFile(name, os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()
	gif.EncodeAll(f, &gif.GIF{
		Image: images,
		Delay: delays,
        
	})

}


package main

import (
    "fmt"
    //  "image/png"
     "image/draw"
	"image/color"
     "image/color/palette"
    // "log"
	"bufio"
    "os"
    "github.com/nfnt/resize"
    "github.com/fogleman/gg"  
    "math/rand"
     "image/gif"
     // "encoding/binary"
    "image"
   // "image/jpeg"
    
    // "io"
   // "github.com/andybons/gogif"
   "time"
   "io/ioutil"

    "github.com/golang/freetype"
    "github.com/golang/freetype/truetype"
)

// func init() {
//     // damn important or else At(), Bounds() functions will
//     // caused memory pointer error!!
//     image.RegisterFormat("jpeg", "jpeg", jpeg.Decode, jpeg.DecodeConfig)
// }

func g103d01g(path string)  {
    // size := 60

	rand.Seed(time.Now().UnixNano())


    fontFile := "/home/mohmedbadrco/goimage/font/Audiowide-Regular.ttf"
    fontBytes, err := ioutil.ReadFile(fontFile)
    fontb, err := freetype.ParseFont(fontBytes)
    // font

    face := truetype.NewFace(fontb, &truetype.Options{Size: 14 ,DPI: 90})

    
	inputFile , err := os.Open(path)
	defer inputFile.Close()
	if err != nil {
		panic(err)
	}

	r := bufio.NewReader(inputFile)
   GIF,err := gif.DecodeAll(r)
//    fmt.Println(g.Image[0].Bounds().Max.X ,err)
 
    // imData, err := png.Decode(catFile)
    // if err != nil {
	// 	// Handle error
	// }
	if err != nil {
		// Handle error
	}
	
   // fmt.Println(imData)

//    _ = imageType
    framesc := len(GIF.Image)
	var frames [8] image.Image
    
    for i := 0;i<framesc;i++{
    imDatan := resize.Resize(0,80, GIF.Image[i], resize.Lanczos3)
	frames[i] = imDatan
 }

    
      
    // const int  ax = imDatan.Bounds().Max.X

    var am [][][2] int


    

   // gscale := "$@B%8&WẄMÄÚŬÛŮÜŨ#*oöøäahkbdpqÞwmZŽO0QLCJUYŸXzcvunxrjft/|()1{}[]?-_+~<>i!lI½¼;:,\"^`'. "
   gscale := "$@B%8&WẄMÄŨ#*oöøäahkbdpqÞwmZŽŒO0QLCJUYŸXzcvüűضصثقفغعهخحيبلاتنمكطئءؤرلاىةوزظunxrjft?-_+~<>i!lI½¼;:,\"^`'. "

    glen := len(gscale)

     rn := rand.Intn(len(gscale) - 10)

      gscale = gscale[rn:rn+1+rand.Intn(glen - rn )]
      gscale += "  "
	// gscale = gscale[rn:]


      glen = len(gscale)
    
    g := rand.Intn(20) + 10
    vis := true
   
	imDatan := frames[0]

   
        for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ {
                    var subam  [][2] int
            for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
            c := color.GrayModel.Convert(imDatan.At(x, y)).(color.Gray)
           
            if (g > 0){
                g--
            }

            if(g <= 0){
                vis = !(vis)
              //  fmt.Println(vis)
                g = rand.Intn(20) + 10
               // fmt.Println(g)
            }
           // fmt.Println(int(c.Y))
            avg := int(((int(c.Y) * glen) / 255))
            if (avg > (glen - 1)){
                avg = glen - 1
            }
            // fmt.Println(avg)
         // k := gscale[avg];
         if(vis){
            if (g == 1){
                var gh = [2] int {avg,1}
                subam = append(subam,gh)

            }else{

                var gh = [2] int {avg,0}
                subam = append(subam,gh)
            }
            
         }else{
            var gh = [2] int {avg,2}
                subam = append(subam,gh)
         }
        
          
            
            // pimage(dc, imDatan.At(x, y), x * 14 ,14 + y *14,string(k))
        }
        am = append(am,subam)
    }
    
    var rcolors [][3] int

	for i := 0;i<10;i++{
		var gh = [3] int {rand.Intn(255),rand.Intn(255),rand.Intn(255)}
    rcolors = append(rcolors,gh)
	}  
	// ho := 0

    var images []*image.Paletted

    var delays []  int 

    for i := 0; i < 80; i++{
		imDatan = frames[i%8]
        dc := gg.NewContext(imDatan.Bounds().Max.X * 14, imDatan.Bounds().Max.Y * 14)

        dc.SetFontFace(face)

        dc.SetRGB(0, 0, 0)
        dc.Fill()
         

        for j := 0; j < len(am) - 1; j++{
        tem := am[j][0][1]
        am[j][0][1] = am[j][len(am[0])-1][1]
        
        
            for k := len(am[0]) - 1; k > 1; k--{
                // fmt.Println(am[j][k][1],am[j][k-1][1])
               am[j][k][1] = am[j][k-1][1]
              // fmt.Println(am[j][k])
                
            }
            am[j][1][1] = tem
        }
		for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ {
			for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
			c := color.GrayModel.Convert(imDatan.At(x, y)).(color.Gray)
		   // fmt.Println(int(c.Y))
			avg := int(((int(c.Y) * glen) / 255))
			if (avg > (glen - 1)){
				avg = glen - 1
			}
			// fmt.Println(avg)
		 // k := gscale[avg]; 
		// fmt.Println(am[x][y][0])
		 am[x][y][0] = avg
	   //   fmt.Println(am[x][y][0])
	   }}

        offrand1 := 0
        offrand2 := 0


		
		v := [2]int{-1,1}
		offrand1 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*1.2 ))*v[rand.Intn(2)] )
		offrand2 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*1.2 ))*v[rand.Intn(2)] )
		// ho = rand.Intn(2*20)
        // if!(ho > 3){

        //     // gscale := "$@B%8&WẄMÄÚŬÛŮÜŨ#*oöøäahkbdpqÞwmZŽO0QLCJUYŸXzcvunxrjft/|()1{}[]?-_+~<>i!lI½¼;:,\"^`'. "
        //     gscale = "$@B%8&WẄMÄŨ#*oöøäahkbdpqÞwmZŽŒO0QLCJUYŸXzcvüűضصثقفغعهخحيبلاتنمكطئءؤرلاىةوزظunxrjft?-_+~<>i!lI½¼;:,\"^`'. "
         
        //      glen = len(gscale)
         
        //       rn = rand.Intn(len(gscale) - 10)
         
        //         gscale = gscale[rn:rn+1+rand.Intn(glen - rn )]
        //         gscale += "  "
        //      // gscale = gscale[rn:]
         
         
        //        glen = len(gscale)
        
            
        //          for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ {
        //              for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
        //              c := color.GrayModel.Convert(imDatan.At(x, y)).(color.Gray)
        //             // fmt.Println(int(c.Y))
        //              avg := int(((int(c.Y) * glen) / 255))
        //              if (avg > (glen - 1)){
        //                  avg = glen - 1
        //              }
        //              // fmt.Println(avg)
        //           // k := gscale[avg]; 
        //          // fmt.Println(am[x][y][0])
        //           am[x][y][0] = avg
        //         //   fmt.Println(am[x][y][0])
        //         }}
                  

		// }

            for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ { 
				if(rand.Intn(20) > 15){
					v := [2]int{-1,1}
					offrand1 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*3 ))*v[rand.Intn(2)] )
					offrand2 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*3 ))*v[rand.Intn(2)] )
				}
				
                for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {


					if(rand.Intn(20) > 15){
						v := [2]int{-1,1}
						offrand1 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*3 ))*v[rand.Intn(2)])
						offrand2 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)*3 ))*v[rand.Intn(2)] )
					}
				
					
                    aR, aG, aB, aA := imDatan.At(x, y).RGBA() // no more error
                _ ,_,_= aR, aG, aB
                glen = len(gscale)
                index := int((float64(am[x][y][0])/float64(glen))*float64(len(rcolors)))
				rc  := rcolors[index]
                // fmt.Println(index)
				if(i < 29 || i > 30){
               if(am[x][y][1] == 0){
                
                pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 ,14 + y *14,string(gscale[am[x][y][0]]))
              pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 ,21 + y *14,string(gscale[am[x][y][0]]))
				


               }
               if(am[x][y][1] == 1){
                
                pimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 ,14 + y *14,string(gscale[am[x][y][0]]))
                pimage(dc, color.RGBA{255, 255, 255, uint8(((aA/8)) >>  8) }, x * 14 + 7 ,21 + y *14,string(gscale[am[x][y][0]]))

               } } else{
                 
				if(am[x][y][1] == 0){
                
					pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 + offrand1 ,14 + y *14 + offrand2,string(gscale[am[x][y][0]]))
				  pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 +offrand1,21 + y *14 + offrand2,string(gscale[am[x][y][0]]))
					
	
	
				   }
				   if(am[x][y][1] == 1){
					
					pimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 + offrand1 ,14 + y *14 + offrand2,string(gscale[am[x][y][0]]))
					pimage(dc, color.RGBA{255, 255, 255, uint8(((aA/8)) >>  8) }, x * 14 + 7 +offrand1,21 + y *14 + offrand2,string(gscale[am[x][y][0]]))
	
				   }

               }

            } 
       
    }

  _ , _ = offrand1,offrand2
    delays = append(delays,7)

    dc.Clip()
    
    bbb := dc.Image()

    palettedImage := image.NewPaletted(image.Rect(0, 0, bbb.Bounds().Max.X, bbb.Bounds().Max.Y), palette.Plan9)
    draw.Draw(palettedImage, palettedImage.Rect, bbb,bbb.Bounds().Min, draw.Over)
     images = append(images,palettedImage)
	  //  dc.SavePNG(fmt.Sprintf("f/a%d.png", i))

}
  now := time.Now()
    name := fmt.Sprintf("out/%srbg.gif",now)
f, err := os.OpenFile(name, os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()
	gif.EncodeAll(f, &gif.GIF{
		Image: images,
		Delay: delays,
        
	})

}

package main

import (
    "fmt"
    //  "image/png"
     "image/draw"
	"image/color"
     "image/color/palette"
    "log"
    "os"
    "github.com/nfnt/resize"
    "github.com/fogleman/gg"  
    "math/rand"
     "image/gif"
     // "encoding/binary"
    "image"
   // "image/jpeg"
    
    // "io"
   // "github.com/andybons/gogif"
   "time"
   "io/ioutil"

    "github.com/golang/freetype"
    "github.com/golang/freetype/truetype"
)

// func init() {
//     // damn important or else At(), Bounds() functions will
//     // caused memory pointer error!!
//     image.RegisterFormat("jpeg", "jpeg", jpeg.Decode, jpeg.DecodeConfig)
// }

func g103dsaw(path string)  {
    size := 60

	rand.Seed(time.Now().UnixNano())


    fontFile := "/home/mohmedbadrco/goimage/font/Audiowide-Regular.ttf"
    fontBytes, err := ioutil.ReadFile(fontFile)
    fontb, err := freetype.ParseFont(fontBytes)
    // font

    face := truetype.NewFace(fontb, &truetype.Options{Size: 14 ,DPI: 90})

    
     catFile, err := os.Open(path)
    if err != nil {
        log.Fatal(err)
    }
    defer catFile.Close()
 
    // imData, err := png.Decode(catFile)
    // if err != nil {
	// 	// Handle error
	// }
    imData, imageType, err := image.Decode(catFile)
	if err != nil {
		// Handle error
	}
	
   // fmt.Println(imData)

   _ = imageType
    
    
    
    imDatan := resize.Resize(0, 60, imData, resize.Lanczos3)

    
      
    // const int  ax = imDatan.Bounds().Max.X

    var am [][][2] int


    

   // gscale := "$@B%8&WẄMÄÚŬÛŮÜŨ#*oöøäahkbdpqÞwmZŽO0QLCJUYŸXzcvunxrjft/|()1{}[]?-_+~<>i!lI½¼;:,\"^`'. "
   gscale := "$@B%8&WMÄZO0QLCJUYX#*oahkbdpqwmzcvűزظunxrjft?-_+~<>i!lI½¼;:,\"^`'. "

    glen := len(gscale)

     rn := rand.Intn(len(gscale) - 10)

      gscale = gscale[rn:rn+rand.Intn(glen - rn )]
      gscale += "  "
	// gscale = gscale[rn:]


      glen = len(gscale)
    
    g := rand.Intn(20) + 10
    vis := true
   

   
        for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ {
                    var subam  [][2] int
            for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
            c := color.GrayModel.Convert(imDatan.At(x, y)).(color.Gray)
           
            if (g > 0){
                g--
            }

            if(g <= 0){
                vis = !(vis)
              //  fmt.Println(vis)
                g = rand.Intn(20) + 10
               // fmt.Println(g)
            }
           // fmt.Println(int(c.Y))
            avg := int(((int(c.Y) * glen) / 255))
            if (avg > (glen - 1)){
                avg = glen - 1
            }
            // fmt.Println(avg)
         // k := gscale[avg];
         if(vis){
            if (g == 1){
                var gh = [2] int {avg,1}
                subam = append(subam,gh)

            }else{

                var gh = [2] int {avg,0}
                subam = append(subam,gh)
            }
            
         }else{
            var gh = [2] int {avg,2}
                subam = append(subam,gh)
         }
        
          
            
            // pimage(dc, imDatan.At(x, y), x * 14 ,14 + y *14,string(k))
        }
        am = append(am,subam)
    }
    
    var rcolors [][3] int

	for i := 0;i<10;i++{
		var gh = [3] int {rand.Intn(255),rand.Intn(255),rand.Intn(255)}
    rcolors = append(rcolors,gh)
	}

    var images []*image.Paletted

    var delays []  int 
	
    for i := 0; i < size; i++{
        dc := gg.NewContext(imDatan.Bounds().Max.X * 14, imDatan.Bounds().Max.Y * 14)

        dc.SetFontFace(face)

        dc.SetRGB(0, 0, 0)
        dc.Fill()
         

        for j := 0; j < len(am) - 1; j++{
        tem := am[j][0][1]
        am[j][0][1] = am[j][len(am[0])-1][1]
        
        
            for k := len(am[0]) - 1; k > 1; k--{
                // fmt.Println(am[j][k][1],am[j][k-1][1])
               am[j][k][1] = am[j][k-1][1]
              // fmt.Println(am[j][k])
                
            }
            am[j][1][1] = tem
        }

       

	
		

            for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ { 
			
				
                for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {


					var offrand1 float64 = float64(rand.Intn(imDatan.Bounds().Max.X))*0.35
					var offrand2 float64 = float64(rand.Intn(imDatan.Bounds().Max.X)*-1)*0.35
					
					
                    aR, aG, aB, aA := imDatan.At(x, y).RGBA() // no more error
                _ ,_,_= aR, aG, aB
                index := int((float64(am[x][y][0])/float64(glen))*float64(len(rcolors)))
				rc  := rcolors[index]
                // fmt.Println(index)
				if(rand.Intn(3)>1){
               if(am[x][y][1] == 0){
                pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 + int(offrand2) ,14 + y *14 + int(offrand2),string(gscale[am[x][y][0]]))
				  pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 +int(offrand2),21 + y *14 + int(offrand2),string(gscale[am[x][y][0]]))

               }
               if(am[x][y][1] == 1){
                
               
                pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 + int(offrand2) ,14 + y *14 + int(offrand2),string(gscale[am[x][y][0]]))
				  pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 + int(offrand2),21 + y *14 + int(offrand2),string(gscale[am[x][y][0]]))

               } } else{
                 
				if(am[x][y][1] == 0){
                
					pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 + int(offrand1) ,14 + y *14 + int(offrand1),string(gscale[am[x][y][0]]))
				  pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 +int(offrand1),21 + y *14 + int(offrand1),string(gscale[am[x][y][0]]))
					
	
	
				   }
				   if(am[x][y][1] == 1){
					
					pimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 + int(offrand1) ,14 + y *14 + int(offrand1),string(gscale[am[x][y][0]]))
					pimage(dc, color.RGBA{255, 255, 255, uint8(((aA/8)) >>  8) }, x * 14 + 7 +int(offrand1),21 + y *14 + int(offrand1),string(gscale[am[x][y][0]]))
	
				   }

               }

            }
			   
			


                

            
       
    }

  // _ , _ = offrand1,offrand2
    delays = append(delays,7)

    dc.Clip()
    
    bbb := dc.Image()

    palettedImage := image.NewPaletted(image.Rect(0, 0, bbb.Bounds().Max.X, bbb.Bounds().Max.Y), palette.Plan9)
    draw.Draw(palettedImage, palettedImage.Rect, bbb,bbb.Bounds().Min, draw.Over)
     images = append(images,palettedImage)
	   // dc.SavePNG(fmt.Sprintf("f/a%d.png", i))

}
  now := time.Now()
    name := fmt.Sprintf("out/%srbg.gif",now)
f, err := os.OpenFile(name, os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()
	gif.EncodeAll(f, &gif.GIF{
		Image: images,
		Delay: delays,
        
	})

}
package main

import (
    "fmt"
    //  "image/png"
     "image/draw"
	"image/color"
     "image/color/palette"
    "log"
    "os"
    "github.com/nfnt/resize"
    "github.com/fogleman/gg"  
    "math/rand"
     "image/gif"
    "image"
   // "image/jpeg"
    
    // "io"
   "time"
   "io/ioutil"

    "github.com/golang/freetype"
    "github.com/golang/freetype/truetype"
)

//shake shake 
func g103d22(path string)  {
    size := 60

	rand.Seed(time.Now().UnixNano())


    fontFile := "/home/mohmedbadrco/goimage/font/Audiowide-Regular.ttf"
    fontBytes, err := ioutil.ReadFile(fontFile)
    fontb, err := freetype.ParseFont(fontBytes)
    // font

    face := truetype.NewFace(fontb, &truetype.Options{Size: 14 ,DPI: 90})

    
     catFile, err := os.Open(path)
    if err != nil {
        log.Fatal(err)
    }
    defer catFile.Close()
 
    // imData, err := png.Decode(catFile)
    // if err != nil {
	// 	// Handle error
	// }
    imData, imageType, err := image.Decode(catFile)
	if err != nil {
		// Handle error
	}
	
   // fmt.Println(imData)

   _ = imageType
    
    
    
    imDatan := resize.Resize(0, 60, imData, resize.Lanczos3)

    
      
    // const int  ax = imDatan.Bounds().Max.X

    var am [][][2] int


    

   // gscale := "$@B%8&WẄMÄÚŬÛŮÜŨ#*oöøäahkbdpqÞwmZŽO0QLCJUYŸXzcvunxrjft/|()1{}[]?-_+~<>i!lI½¼;:,\"^`'s. "
   gscale := "$@B%8&WẄMÄ#*oöøäahkbdpqÞwmZŽŒO0QLCJUYŸXzcvúùŭûůüűunxrjft?-_+~<>i!lI½¼;:,\"^`'.    "
  // gscale = "صثقفغعهخحزوةىلارؤءسشثقفغعهخحجكوتع٦فقبلاتةцчџшщъыьэюяΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρστυφχψωάΆέΈέΉίϊΐΊόΌύΰϋΎΫάέίόύΏĂÂ  "
  // gscale = "صثقفغعهخحزوةىلارؤءسشثقفغعهخحجكوتع٦فقبلاتة  "

    glen := len(gscale)

     rn := rand.Intn(len(gscale) - 10)

     // gscale = gscale[rn:rn+rand.Intn(glen - rn )]
	  gscale = gscale[rn:]
	 // gscale = "01 "
	// gscale = "#%*+=-:  "

      glen = len(gscale)
    
    g := rand.Intn(20) + 10
    vis := true
   

   
        for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ {
                    var subam  [][2] int
            for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
            c := color.GrayModel.Convert(imDatan.At(x, y)).(color.Gray)
           
            if (g > 0){
                g--
            }

            if(g <= 0){
                vis = !(vis)
              //  fmt.Println(vis)
                g = rand.Intn(20) + 10
               // fmt.Println(g)
            }
           // fmt.Println(int(c.Y))
            avg := int(((int(c.Y) * glen) / 255))
            if (avg > (glen - 1)){
                avg = glen - 1
            }
            // fmt.Println(avg)
         // k := gscale[avg];
         if(vis){
            if (g == 1){
                var gh = [2] int {avg,1}
                subam = append(subam,gh)

            }else{

                var gh = [2] int {avg,0}
                subam = append(subam,gh)
            }
            
         }else{
            var gh = [2] int {avg,2}
                subam = append(subam,gh)
         }
        
          
            
            // pimage(dc, imDatan.At(x, y), x * 14 ,14 + y *14,string(k))
        }
        am = append(am,subam)
    }
    
    var rcolors [][3] int

	for i := 0;i<10;i++{
		var gh = [3] int {rand.Intn(255),rand.Intn(255),rand.Intn(255)}
    rcolors = append(rcolors,gh)
	}

    var images []*image.Paletted

    var delays []  int 

    for i := 0; i < size; i++{
        dc := gg.NewContext(imDatan.Bounds().Max.X * 14, imDatan.Bounds().Max.Y * 14)

        dc.SetFontFace(face)

        dc.SetRGB(0, 0, 0)
        dc.Fill()
         

        for j := 0; j < len(am) - 1; j++{
        tem := am[j][0][1]
        am[j][0][1] = am[j][len(am[0])-1][1]
        
        
            for k := len(am[0]) - 1; k > 1; k--{
                // fmt.Println(am[j][k][1],am[j][k-1][1])
               am[j][k][1] = am[j][k-1][1]
              // fmt.Println(am[j][k])
                
            }
            am[j][1][1] = tem
        }
		v := [2]int{-1,1}
				ratio := 0.5		
         off1 := (rand.Intn(int(float64(imDatan.Bounds().Max.X)*ratio))*v[rand.Intn(2)] )
		 off2 := (rand.Intn(int(float64(imDatan.Bounds().Max.X)*ratio))*v[rand.Intn(2)] )
		 off11 := (rand.Intn(int(float64(imDatan.Bounds().Max.X)*ratio))*v[rand.Intn(2)] )
		 off22 := (rand.Intn(int(float64(imDatan.Bounds().Max.X)*ratio))*v[rand.Intn(2)] )
		//  if(rand.Intn(2) > 0){
        //     off1 = rand.Intn(int(float64(imDatan.Bounds().Max.X)*0.02*14))  
		//     off2 = rand.Intn(int(float64(imDatan.Bounds().Max.X)*0.05*14))  
		// 	// fmt.Println(off2)
		//  }else{
		// 	off1 = -rand.Intn(int(float64(imDatan.Bounds().Max.X)*0.02*14))  
		// 	off2 = -rand.Intn(int(float64(imDatan.Bounds().Max.X)*0.02*14))  
		// 	// fmt.Println(off2)
		// 	// fmt.Println(rand.Intn(2))
		//  }
        


            for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ { 
              
                for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
                    aR, aG, aB, aA := imDatan.At(x, y).RGBA() // no more error
                _ ,_,_= aR, aG, aB
                index := int((float64(am[x][y][0])/float64(glen))*float64(len(rcolors)))
				rc  := rcolors[index]
                // fmt.Println(index)
				
               if(am[x][y][1] == 0){
                
                pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) },x * 14 + off11 ,off22 + 14 + y *14 ,string(gscale[am[x][y][0]]))
              pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/5)) >>  8) }, x * 14 + off1 ,off2 + 14 + y *14 ,string(gscale[am[x][y][0]]))
				


               }
               if(am[x][y][1] == 1){
                
                pimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 + off11 ,off22 + 14 + y *14 ,string(gscale[am[x][y][0]]))
                pimage(dc, color.RGBA{255, 255, 255, uint8(((aA/5)) >>  8) }, x * 14 + off1 ,14 + off2 + y *14,string(gscale[am[x][y][0]]))

               }  

            }
			   
			

    }

  
    delays = append(delays,7)

    dc.Clip()
    
    bbb := dc.Image()

    palettedImage := image.NewPaletted(image.Rect(0, 0, bbb.Bounds().Max.X, bbb.Bounds().Max.Y), palette.Plan9)
    draw.Draw(palettedImage, palettedImage.Rect, bbb,bbb.Bounds().Min, draw.Over)
     images = append(images,palettedImage)
	   // dc.SavePNG(fmt.Sprintf("f/a%d.png", i))

}
  now := time.Now()
    name := fmt.Sprintf("out/%srbg.gif",now)
f, err := os.OpenFile(name, os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()
	gif.EncodeAll(f, &gif.GIF{
		Image: images,
		Delay: delays,
        BackgroundIndex: byte(rand.Intn(255)) ,
	})

}


package main

import (
    "fmt"
    //  "image/png"
     "image/draw"
	"image/color"
     "image/color/palette"
    "log"
    "os"
    "github.com/nfnt/resize"
    "github.com/fogleman/gg"  
    "math/rand"
     "image/gif"
     // "encoding/binary"
    "image"
   // "image/jpeg"
    
    // "io"
   // "github.com/andybons/gogif"
   "time"
   "io/ioutil"

    "github.com/golang/freetype"
    "github.com/golang/freetype/truetype"
)

// func init() {
//     // damn important or else At(), Bounds() functions will
//     // caused memory pointer error!!
//     image.RegisterFormat("jpeg", "jpeg", jpeg.Decode, jpeg.DecodeConfig)
// }

func culoff (){
	scale := 80

	v := [2]int{-1,1}
	o := int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
	_ = o
	return
}

func g103d80(path string)  {
    size := 60

	rand.Seed(time.Now().UnixNano())


    fontFile := "/home/mohmedbadrco/goimage/font/Audiowide-Regular.ttf"
    fontBytes, err := ioutil.ReadFile(fontFile)
    fontb, err := freetype.ParseFont(fontBytes)
    // font

    face := truetype.NewFace(fontb, &truetype.Options{Size: 14 ,DPI: 90})

    
     catFile, err := os.Open(path)
    if err != nil {
        log.Fatal(err)
    }
    defer catFile.Close()
 
    // imData, err := png.Decode(catFile)
    // if err != nil {
	// 	// Handle error
	// }
    imData, imageType, err := image.Decode(catFile)
	if err != nil {
		// Handle error
	}
	
   // fmt.Println(imData)

   _ = imageType
    
    
    
    imDatan := resize.Resize(0, 60, imData, resize.Lanczos3)

    
      
    // const int  ax = imDatan.Bounds().Max.X

    var am [][][2] int


    

   // gscale := "$@B%8&WẄMÄÚŬÛŮÜŨ#*oöøäahkbdpqÞwmZŽO0QLCJUYŸXzcvunxrjft/|()1{}[]?-_+~<>i!lI½¼;:,\"^`'. "
   gscale := "$@B%8&WMÄZO0QLCJUYX#*oahkbdpqwmzcvűزظunxrjft?-_+~<>i!lI½¼;:,\"^`'. "

    glen := len(gscale)

     rn := rand.Intn(len(gscale) - 10)

      gscale = gscale[rn:rn+rand.Intn(glen - rn )]
    //   gscale += "  "
	// gscale = gscale[rn:]


      glen = len(gscale)
    
    g := rand.Intn(20) + 10
    vis := true
   

   
        for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ {
                    var subam  [][2] int
            for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
            c := color.GrayModel.Convert(imDatan.At(x, y)).(color.Gray)
           
            if (g > 0){
                g--
            }

            if(g <= 0){
                vis = !(vis)
              //  fmt.Println(vis)
                g = rand.Intn(20) + 10
               // fmt.Println(g)
            }
           // fmt.Println(int(c.Y))
            avg := int(((int(c.Y) * glen) / 255))
            if (avg > (glen - 1)){
                avg = glen - 1
            }
            // fmt.Println(avg)
         // k := gscale[avg];
         if(vis){
            if (g == 1){
                var gh = [2] int {avg,1}
                subam = append(subam,gh)

            }else{

                var gh = [2] int {avg,0}
                subam = append(subam,gh)
            }
            
         }else{
            var gh = [2] int {avg,2}
                subam = append(subam,gh)
         }
        
          
            
            // pimage(dc, imDatan.At(x, y), x * 14 ,14 + y *14,string(k))
        }
        am = append(am,subam)
    }
    
    var rcolors [][3] int

	for i := 0;i<10;i++{
		var gh = [3] int {rand.Intn(255),rand.Intn(255),rand.Intn(255)}
    rcolors = append(rcolors,gh)
	}

    var images []*image.Paletted

    var delays []  int 

    for i := 0; i < size; i++{
        dc := gg.NewContext(imDatan.Bounds().Max.X * 14, imDatan.Bounds().Max.Y * 14)

        dc.SetFontFace(face)

        dc.SetRGB(0, 0, 0)
        dc.Fill()
         

        for j := 0; j < len(am) - 1; j++{
        tem := am[j][0][1]
        am[j][0][1] = am[j][len(am[0])-1][1]
        
        
            for k := len(am[0]) - 1; k > 1; k--{
                // fmt.Println(am[j][k][1],am[j][k-1][1])
               am[j][k][1] = am[j][k-1][1]
              // fmt.Println(am[j][k])
                
            }
            am[j][1][1] = tem
        }

        offrand1 := 0
        offrand2 := 0
		offrand11 := 0
        offrand22 := 0
		scale := 80

	v := [2]int{-1,1}
	
       
		offrand1 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
		offrand2 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
		offrand11 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
		offrand22 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
		

            for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ { 
				if(rand.Intn(20) > 15){
					v := [2]int{-1,1}
					offrand1 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
		offrand2 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
		offrand11 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
		offrand22 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
				}
				
                for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {


					if(rand.Intn(20) > 15){
						v := [2]int{-1,1}
						offrand1 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
						offrand2 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
						offrand11 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
						offrand22 = int(rand.Intn(int(float64(scale)))*v[rand.Intn(2)])
					}
				
					
                    aR, aG, aB, aA := imDatan.At(x, y).RGBA() // no more error
                _ ,_,_= aR, aG, aB
                index := int((float64(am[x][y][0])/float64(glen))*float64(len(rcolors)))
				rc  := rcolors[index]
                // fmt.Println(index)
				if(i<29 || i>31){
               if(am[x][y][1] == 0){
                
                pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 ,14 + y *14,string(gscale[am[x][y][0]]))
              pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 ,21 + y *14,string(gscale[am[x][y][0]]))
				


               }
               if(am[x][y][1] == 1){
                
                pimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 ,14 + y *14,string(gscale[am[x][y][0]]))
                pimage(dc, color.RGBA{255, 255, 255, uint8(((aA/8)) >>  8) }, x * 14 + 7 ,21 + y *14,string(gscale[am[x][y][0]]))

               } } else{
                 
				if(am[x][y][1] == 0){
                
					pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 + offrand1 ,14 + y *14 + offrand2,string(gscale[am[x][y][0]]))
				  pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 +offrand11,21 + y *14 + offrand22,string(gscale[am[x][y][0]]))
					
	
	
				   }
				   if(am[x][y][1] == 1){
					
					pimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 + offrand1 ,14 + y *14 + offrand2,string(gscale[am[x][y][0]]))
					pimage(dc, color.RGBA{255, 255, 255, uint8(((aA/8)) >>  8) }, x * 14 + 7 +offrand11,21 + y *14 + offrand22,string(gscale[am[x][y][0]]))
	
				   }

               }

            }    
    }

  _ , _ = offrand1,offrand2
    delays = append(delays,7)

    dc.Clip()
    
    bbb := dc.Image()

    palettedImage := image.NewPaletted(image.Rect(0, 0, bbb.Bounds().Max.X, bbb.Bounds().Max.Y), palette.Plan9)
    draw.Draw(palettedImage, palettedImage.Rect, bbb,bbb.Bounds().Min, draw.Over)
     images = append(images,palettedImage)
	   // dc.SavePNG(fmt.Sprintf("f/a%d.png", i))

}
  now := time.Now()
    name := fmt.Sprintf("out/%srbg.gif",now)
f, err := os.OpenFile(name, os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()
	gif.EncodeAll(f, &gif.GIF{
		Image: images,
		Delay: delays,
        
	})

}


package main

import (
    "fmt"
    //  "image/png"
     "image/draw"
	"image/color"
     "image/color/palette"
    "log"
    "os"
    "github.com/nfnt/resize"
    "github.com/fogleman/gg"  
    "math/rand"
     "image/gif"
     // "encoding/binary"
    "image"
   // "image/jpeg"
    
    // "io"
   // "github.com/andybons/gogif"
   "time"
   "io/ioutil"

    "github.com/golang/freetype"
    "github.com/golang/freetype/truetype"
)

// func init() {
//     // damn important or else At(), Bounds() functions will
//     // caused memory pointer error!!
//     image.RegisterFormat("jpeg", "jpeg", jpeg.Decode, jpeg.DecodeConfig)
// }

func g103d82(path string)  {
    size := 60

	rand.Seed(time.Now().UnixNano())


    fontFile := "/home/mohmedbadrco/goimage/font/Audiowide-Regular.ttf"
    fontBytes, err := ioutil.ReadFile(fontFile)
    fontb, err := freetype.ParseFont(fontBytes)
    // font

    face := truetype.NewFace(fontb, &truetype.Options{Size: 14 ,DPI: 90})

    
     catFile, err := os.Open(path)
    if err != nil {
        log.Fatal(err)
    }
    defer catFile.Close()
 
    // imData, err := png.Decode(catFile)
    // if err != nil {
	// 	// Handle error
	// }
    imData, imageType, err := image.Decode(catFile)
	if err != nil {
		// Handle error
	}
	
   // fmt.Println(imData)

   _ = imageType
    
    
    
    imDatan := resize.Resize(0, 60, imData, resize.Lanczos3)

    
      
    // const int  ax = imDatan.Bounds().Max.X

    var am [][][2] int


    

   // gscale := "$@B%8&WẄMÄÚŬÛŮÜŨ#*oöøäahkbdpqÞwmZŽO0QLCJUYŸXzcvunxrjft/|()1{}[]?-_+~<>i!lI½¼;:,\"^`'. "
  // gscale := "$@B%8&WMÄZO0QLCJUYX#*oahkbdpqwmzcvűزظunxrjft?-_+~<>i!lI½¼;:,\"^`'. "

   // glen := len(gscale)

   //  rn := rand.Intn(len(gscale) - 10)

    //  gscale = gscale[rn:rn+rand.Intn(glen - rn )]
	length := rand.Intn(60)
  
    ran_str := make([]byte, length)
  
    // Generating Random string
    for i := 0; i < length; i++ {
        ran_str[i] = byte(rand.Intn(255))
    }
  
    // Displaying the random string
    str := string(ran_str)
    fmt.Println(str)
	gscale := str
      gscale += "  "
	// gscale = gscale[rn:]


      glen := len(gscale)
    
    g := rand.Intn(20) + 10
    vis := true
   

   
        for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ {
                    var subam  [][2] int
            for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
            c := color.GrayModel.Convert(imDatan.At(x, y)).(color.Gray)
           
            if (g > 0){
                g--
            }

            if(g <= 0){
                vis = !(vis)
              //  fmt.Println(vis)
                g = rand.Intn(20) + 10
               // fmt.Println(g)
            }
           // fmt.Println(int(c.Y))
            avg := int(((int(c.Y) * glen) / 255))
            if (avg > (glen - 1)){
                avg = glen - 1
            }
            // fmt.Println(avg)
         // k := gscale[avg];
         if(vis){
            if (g == 1){
                var gh = [2] int {avg,1}
                subam = append(subam,gh)

            }else{

                var gh = [2] int {avg,0}
                subam = append(subam,gh)
            }
            
         }else{
            var gh = [2] int {avg,2}
                subam = append(subam,gh)
         }
        
          
            
            // pimage(dc, imDatan.At(x, y), x * 14 ,14 + y *14,string(k))
        }
        am = append(am,subam)
    }
    
    var rcolors [][3] int

	for i := 0;i<10;i++{
		var gh = [3] int {rand.Intn(255),rand.Intn(255),rand.Intn(255)}
    rcolors = append(rcolors,gh)
	}

    var images []*image.Paletted

    var delays []  int 

    for i := 0; i < size; i++{
        dc := gg.NewContext(imDatan.Bounds().Max.X * 14, (imDatan.Bounds().Max.Y)* 14)

        dc.SetFontFace(face)

        dc.SetRGB(0, 0, 0)
        dc.Fill()
         

        for j := 0; j < len(am) - 1; j++{
        tem := am[j][0][1]
        am[j][0][1] = am[j][len(am[0])-1][1]
        
        
            for k := len(am[0]) - 1; k > 1; k--{
                // fmt.Println(am[j][k][1],am[j][k-1][1])
               am[j][k][1] = am[j][k-1][1]
              // fmt.Println(am[j][k])
                
            }
            am[j][1][1] = tem
        }

        offrand1 := 0
        offrand2 := 0


		v := [2]int{-3,3}
		offrand1 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)))*v[rand.Intn(2)] )
		offrand2 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)))*v[rand.Intn(2)] )
		    o := 0

            for x := imDatan.Bounds().Min.X; x < imDatan.Bounds().Max.X; x++ { 
				if(rand.Intn(20) > 10){
					v := [2]int{-3,3}
					offrand1 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)))*v[rand.Intn(2)] )
					offrand2 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)))*v[rand.Intn(2)] )
				}
                if(rand.Intn(1000) < 25){
                    vo := []int{-1,2,4,-3,1,3,-4,-2}
                    o = 14*vo[rand.Intn(6)]
                   }else{
                       o = 0
                   }
				
                for y := imDatan.Bounds().Min.Y; y < imDatan.Bounds().Max.Y; y++ {
                    


					if(rand.Intn(20) > 10){
						v := [2]int{-3,3}
						offrand1 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)))*v[rand.Intn(2)] )
						offrand2 = (rand.Intn(int(float64(imDatan.Bounds().Max.X)))*v[rand.Intn(2)] )
					}
				
					
                    aR, aG, aB, aA := imDatan.At(x, y).RGBA() // no more error
                _ ,_,_= aR, aG, aB
                index := int((float64(am[x][y][0])/float64(glen))*float64(len(rcolors)))
				rc  := rcolors[index]
                // fmt.Println(index)
				if(i<29 || i>31){
              if(rand.Intn(255) > 1){
			  if(am[x][y][1] == 0){
                
                pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 ,o + 14 + 14 + y *14,string(gscale[am[x][y][0]]))
              pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 ,o + 14 + 21 + y *14,string(gscale[am[x][y][0]]))
				


               }
               if(am[x][y][1] == 1){
                
                rpimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 ,o + 14 + 14 + y *14,string(gscale[am[x][y][0]]))
                rpimage(dc, color.RGBA{255, 255, 255, uint8(((aA/8)) >>  8) }, x * 14 + 7 , o + 14 + 21 + y *14,string(gscale[am[x][y][0]]))

               }  }else{
                if(am[x][y][1] == 0){
                
                    rpimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 ,o + 14 + 14 + y *14,string(gscale[am[x][y][0]]))
                  rpimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 ,o + 14 + 21 + y *14,string(gscale[am[x][y][0]]))
                    
    
    
                   }
                   if(am[x][y][1] == 1){
                    
                    rpimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 ,o + 14 + 14 + y *14,string(gscale[am[x][y][0]]))
                    rpimage(dc, color.RGBA{255, 255, 255, uint8(((aA/8)) >>  8) }, x * 14 + 7 , o + 14 + 21 + y *14,string(gscale[am[x][y][0]]))
    
                   } 

               }
			   } else{
                 
				if(am[x][y][1] == 0){
                
					pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(aA  >>  8) }, x * 14 + offrand1 ,14 + y *14 + offrand2,string(gscale[am[x][y][0]]))
				  pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), uint8(((aA/8)) >>  8) }, x * 14 + 7 +offrand1,21 + y *14 + offrand2,string(gscale[am[x][y][0]]))
					
	
	
				   }
				   if(am[x][y][1] == 1){
					
					rpimage(dc, color.RGBA{255, 255, 255, uint8(aA >>  8) }, x * 14 + offrand1 ,14 + y *14 + offrand2,string(gscale[am[x][y][0]]))
					rpimage(dc, color.RGBA{255, 255, 255, uint8(((aA/8)) >>  8) }, x * 14 + 7 +offrand1,21 + y *14 + offrand2,string(gscale[am[x][y][0]]))
	
				   }

               }

            }
			   
			
           

            
       
    }

  _ , _ = offrand1,offrand2
  
  for j := 0; j < glen; j++{
  rc  := rcolors[int(gscale[j])*10/255]
  if(rand.Intn(255) > 2){
  pimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), 255 }, j*14 ,16,string(gscale[j])) 
  }else
  {  rpimage(dc, color.RGBA{uint8( rc[0]),uint8(rc[1]), uint8(rc[2]), 255 }, j*14 ,14,string(gscale[j]))
  }
  }
    delays = append(delays,7)

    dc.Clip()
    
    bbb := dc.Image()

    palettedImage := image.NewPaletted(image.Rect(0, 0, bbb.Bounds().Max.X, bbb.Bounds().Max.Y), palette.Plan9)
    draw.Draw(palettedImage, palettedImage.Rect, bbb,bbb.Bounds().Min, draw.Over)
     images = append(images,palettedImage)
	   // dc.SavePNG(fmt.Sprintf("f/a%d.png", i))

}
  now := time.Now()
    name := fmt.Sprintf("out/%srbg.gif",now)
f, err := os.OpenFile(name, os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()
	gif.EncodeAll(f, &gif.GIF{
		Image: images,
		Delay: delays,
        
	})

}



